# 指针与地址
【问答题】
  1、以下是三重指针的程序片段：

    int num = 100;
    int ＊ptr1 = &num;
    int ＊＊ptr2 = &ptr1;
    int ＊＊＊ptr3 = &ptr2;
请回答以下问题：
（a）**ptr2与***ptr3的值是多少？
（b）试说明ptr2与*ptr3是否相等。为什么？

解答：
（a）都为100。
（b）因为ptr3是指向ptr2的整数类型三重指针，所以ptr3所存放的内容为ptr2的地址（&ptr2）, *ptr3即为ptr2所存放的内容，两者是相等的。



2、*c = b与c = &b有什么相同与不同之处？

解答：*c = b表示将变量b的值存储至c所指向的内存位置，如果我们改变了c内存位置的值，对b的值将不会有影响。c = &b表示将b内存的位置赋值给c，此时若将其他的值赋值给*c，则b的值也将跟着改变。



3、请使用简单的文字来解释下列变量所代表的意思：

    int ＊prt0;
    int ＊prt1 = 2000;
    int ＊prt2 = NULL;
解答：
int *prt1 = 2000；表示声明一个指针变量，且直接分配内存地址2000给指针变量。
int *prt2 = NULL；表示声明一个指针变量，并分配一个空地址给指针变量，但没有真实的内存空间。



4、有一个变量val，我们想把它的值存在内存地址0x1000中，请问应该如何编写程序代码？并说明程序流程。

解答：

```
int val = 5; //声明一个int数据类型的val变量
int *prt3 = (int *)0x1000; //声明一个内存地址为0x1000的变量prt3，且prt3 = &val;
```



5、请说明下列程序代码所代表的意义。

    int ＊prt = new int ;

解答：声明一个int类型的动态变量，并分配一个新的int数据类型的内存空间给变量来使用。



6、下列程序代码的写法正确吗？

```
int a1, ＊p1=0;  // 声明变量a1及指针变量p1，并且将指针变量p1的初值设置为0
```

解答：不正确。



7、指针的操作需通过哪两种运算符？

解答：取址运算符“&”与取值运算符“*”。



8、请使用指针模式来表示arr[i][j]的内存地址。

解答：*(arr+i)+j。



9、试说明指针变量在目前的操作系统下占用内存的情况。

解答：由于指针变量只是存储内存地址，因此在目前的操作系统下，无论声明为什么数据类型的指针变量都只会占用4个字节。



10、下面这个程序有什么错误？

    01 #include <iostream>
    02
    03 int main(void)
    04 {
    05      char ＊str;
    06
    07     cout<<"请输入字符串：";
    08      cin>>str;
    09     cout<<"输入的字符串："<< str<<endl;
    10
    11      return 0;
    12 }
解答：str指针没有初始化，不可直接存取，否则会造成不可预期的错误。



11、下面这个程序是一个初学指针的学生所编写的。他希望通过操作指针q来改变变量p的值，原先想要p的值为2，但却打印出了奇怪的结果。请问错误出在哪里？

    01 #include <iostream >
    02
    03 int main(void)
    04 {
    05      int p = 1, ＊q;
    06
    07      q = &p;
    08      ＊q++;
    09      cout<<"p ="<<p<<endl;
    10      cout<<"＊q ="<<＊q<<endl;
    11
    12      return 0;
    13 }
解答：++运算符的优先级高于*运算符，原程序是先移动q的内存地址再取出其值，这个程序要按题意改变p的值可将原第8行修改如下：

        (＊q)++;



12、当声明数组与指针获取内存中变量的数据时，两者有什么差异？

解答：数组适合声明固定区块的变量数据，可以防止读取或写入时超出设置数据范围的内存区块；指针不适合一定范围内的内存读取，因为地址值有可能已经超出设置范围，从而造成读取或是写入错误。



13、下列程序代码为圆半径的设置，请写出第7行的打印结果。

    01  #include <iostream>
    02  int main()
    03  {
    04       int iRadius=10;
    05       int＊ piRadius=&iRadius;
    06
    07      cout<<"＊piRadius值为"<<＊piRadius<<endl;
    08       return 0;
    09  }
解答：第7行的打印结果为：*piRadius值为10。



14、指针的加法运算和一般变量的加法运算有什么不同？

解答：最大的差异在于当我们执行指针加法运算后会将当前指针变量所指向的内存地址“向后”移动。



15、在下列程序代码中，声明一个数组指针以及设置初值的方式是否正确？

    int ＊p1;
    int array1[5];
    p1=array1;
解答：正确



16、下列程序的说明是否正确？

    char＊ s1= "This is a Key " ;  //声明字符串指针
    char ＊p1;  //声明指针变量
解答：正确



17、下列程序代码的最后内存地址是多少？请说明理由。

    int ＊prt = (int ＊) 1000 ;
    prt+=3;
    prt--;
解答：1008。最初的内存地址为1000，“prt+=3”是将内存地址往后取3个int数据长度，int数据长度为4个字节，所以一共移动了12个字节，现在的内存地址为1012，而“prt--”往前移动了4个字节，所以最后停留的内存地址为“1008”。



18、请简单说明指针运算的意义与作用。

解答：指针变量虽然是一种用来存储地址值的变量，也可以对指针使用+运算符或-运算符来进行运算，不过运算结果与一般变量大不相同。事实上，当我们对指针变量使用这两个运算符时并不是进行一般变量的加法或减法运算，而是用来增减内存地址的偏移量，而移动的基本单位则视所声明的数据类型而定。



19、请问以下程序代码哪一行有错误？试说明原因。

    01  int value=255;
    02  int ＊piVal, ＊piVal1;
    03  float ＊ppp;
    04  piVal= &value;
    05  piVal1=piVal;
    06  ppp=piVal1;
解答：第6行因为一旦确定指针所指向的数据类型，就不能再更改了。另外，指针变量也不能指向不同数据类型的指针变量。



20、以下程序代码是四重指针的
李鹏  23:42:46
应用，请问***ptr与****ptr的值是多少？请加以说明。

    01  int num = 1000;
    02  int ＊ptr1 = &num;
    03  int ＊＊ptr2 = &ptr1;
    04  int ＊＊＊ptr3 = &ptr2;
    05  int ＊＊＊＊ptr4 = &ptr3;
解答：都为1000



21、请问以下程序代码是否有错？请加以说明。

    01  int arr[10], value=100;
    02  int ＊ptr=&value;
    03  arr=ptr;
解答：第3行有错，因为数组可以直接当成指针常数来用，而数组名地址则是数组第一个元素的地址。不过，由于数组的地址是只读的，因此不能改变其值，这点是和指针变量最大的不同。



22、请问如何获取一维数组的长度大小？

解答：数组长度=sizeof(数组名)/sizeof(数组名[0])



23、数组名本身存储有内存地址，假设有一个二维数组名为arr，该如何使用指针变量ptr取代arr来取出所有的元素值？

解答：这个题目主要是在考验我们对指针的认识，以及指针与数组之间的关系。二维数组名是一个双重指针，所以也必须使用双重指针来取代，可以声明指针数组来进行这项操作。



24、什么是指针引用？

解答：指针与引用之间也可以结合使用，也就是将引用的初值指向某个指针变量的地址，也就是指针引用。



25、动态分配数组的优点是什么？

解答：使用动态分配数组可以在程序运行时临时决定数组大小。动态分配数组方式与动态分配变量的方式类似，声明后会在内存中自动寻找适合的连续内存空间，其长度必须与指定数据类型长度再乘以数组的长度相符。分配完成后，再将该内存区段的起始地址返回给等号左边所声明的指针变量。



26、什么是指针数组？

解答：指针也可以像其他变量一样声明成数组方式，即指针数组。每个指针数组中的元素都是一个指针变量，元素值为指向其他变量的地址值。



27、请说明内存泄漏的含义。

解答：如果程序运行期间分配的内存未释放，就会造成内存空间的浪费，形成所谓的内存泄漏。这种情况对于需要一次使用海量内存的程序将有可能发生无法运行或导致系统运行越来越缓慢等情况发生。



28、请简述为何要使用动态分配内存以及动态分配内存的优点是什么。

解答：动态分配内存可以使数据声明的操作在程序运行时再做决定；对于整个操作系统而言，可让其他更需要内存的程序有更弹性的内存使用量。好处是：首先，程序可以按所需的容量分配内存；其次，若内存容量不充足时，程序执行都以静态声明方式分配内存，如此可能导致程序刚运行就面临内存不足的现象，从而造成程序无法运行的窘境。



29、如何使用一个循环列出二维数组中所有的元素值？

解答：即使是二维数组，在内存中也是线性排列的，我们只要先设法取得第一个元素的内存地址即可使用一个循环来取出数组中所有的元素值。



30、下面这个程序有无错误？如果有错，如何修正？

      01 #include <iostream>
      02
      03 int main(void)
      04 {
      05      char p[80];
      06
      07      p = "123456789";
      08
      09      cout<< p;
      10      return 0;
      11 }
解答：不可以直接把字符串常数赋值给固定长度的字符数组，如果要在程序中直接使用字符串常数设置字符串，就必须使用字符指针。程序的第5行应修改如下：

      char ＊p;



31、在程序中如何声明指针，指针必须定义哪些内容或赋予哪些内容？

解答：在声明指针时，必须定义指针属于何种数据类型。在数据类型后加上“*”符号，再赋予指针名称，即可声明一个指针变量。



32、下面的程序有什么错误？

      01 #include <iostream>
      02
      03 int main(void)
      04 {
      05      int＊ x, y;
      06      int input;
      07
      08      x = &input;
      09      y = &input;
      10      cout<<"x = "<<x<<endl;
      11      cout<<"y = ", <<y<<endl;
      12
      13      return 0;
      14 }
解答：第5行有错误，这是一个经常发生的错误，原程序中只声明x为整数指针，而y被声明为整数变量，因而要修正程序，应将第5行修改如下：

      int ＊x, ＊y;



33、请说明取址运算符“&”与取值运算符“*”的作用是什么。

解答：取址运算符“&”用来获取变量存储数据的地址值，取值运算符“*”用来获取指针变量值所代表地址的数据内容。

